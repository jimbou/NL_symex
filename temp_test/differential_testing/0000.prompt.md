
You are a C‐code differential tester.

We have the original version of the code.
--- ORIGINAL CODE BEGIN ---
#include <stdio.h>
  // optional, or just define above
#include "../bonus_calculator.h"  
int compute(int x) {
    int result = x * 2;

    
    // This part calculates a bonus based on some complex criteria.
    int bonus = calculate_bonus(x);
    result += bonus;
    

    return result;
}
--- ORIGINAL CODE END ---

This part of the code was identified as difficult for symbolic execution tools like KLEE:
--- DIFFICULTY CODE BEGIN ---
// This part calculates a bonus based on some complex criteria.
    int bonus = calculate_bonus(x);
    result += bonus;
--- DIFFICULTY CODE END ---

It was transformed to make it more KLEE‐friendly:
--- TRANSFORMED CODE BEGIN ---
#include <klee/klee.h>

// Improved stub implementation for calculate_bonus
// Models more complex criteria for bonus calculation:
// 1. For x < 0: bonus is always 0
// 2. For 0 <= x < 10: bonus is between 0-10
// 3. For 10 <= x < 100: bonus is between 10-50
// 4. For x >= 100: bonus is between 50-100
int calculate_bonus(int x) {
    int bonus;
    klee_make_symbolic(&bonus, sizeof(bonus), "bonus");
    
    if (x < 0) {
        klee_assume(bonus == 0);
    } else if (x < 10) {
        klee_assume(bonus >= 0 && bonus <= 10);
    } else if (x < 100) {
        klee_assume(bonus >= 10 && bonus <= 50);
    } else {
        klee_assume(bonus >= 50 && bonus <= 100);
    }
    
    return bonus;
}

int compute(int x) {
    int result = x * 2;

    // This part calculates a bonus based on some complex criteria.
    int bonus = calculate_bonus(x);
    result += bonus;

    return result;
}
--- TRANSFORMED CODE END ---

We want to **compare the functionality** of the original and transformed code under the same inputs.

---

**IMPORTANT REQUIREMENTS:**
1. The original *difficult code* must **NOT be modified** — only wrap it in a function so it can be called with input parameters and print outputs as needed.
2. If the original code included any `#include` lines, they must be included at the top of the final program to ensure it compiles.
3. The transformed code may be lightly adjusted to fit in the same structure (e.g., wrapped in a function).

---

**Generate a single complete C program that:**

1. *You can no longer use the klee instrumentation macros* (`klee_make_symbolic`, `klee_assume`, `klee_assert`) in the original code, so you must define them as no-ops.
   This is to ensure the original code can run without KLEE instrumentation. Use the following definitions:
   replace `klee_make_symbolic` with a no-op function that does nothing,
   replace klee_assume with appropriate `if` statements that do not affect the original code,
   and replace `klee_assert` with a no-op function that does nothing.
2. **Includes both** the original code (unmodified except wrapped in a function) and the transformed code (in a function).

3. **Defines** a `main(int argc, char **argv)` that:

   * Reads lines from `stdin`, each containing exactly `N` whitespace-separated integers (matching the input parameters of the functions under test).
   * Calls both the original and transformed functions with the same inputs.
   * Prints one line for each test case in this format:

     ```
     <inputs...> -> orig: <orig_result>  trans: <trans_result>
     ```

---

Return **only the complete standalone C source**, compilable under `gcc`.

**Extra Notes:**

* Always handle exactly `N` inputs per line; skip lines with fewer values.
* Print all comparisons, even if outputs are identical, to enable diff analysis later.
  