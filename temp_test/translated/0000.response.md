Here's the transformed code that replaces the external `calculate_bonus()` function with symbolic variables and assumptions:

### Transformed C Code:
Start_of_transformed_code
```c
#include <klee/klee.h>

int compute(int x) {
    int result = x * 2;

    // Replace external bonus calculation with symbolic variable
    int bonus;
    klee_make_symbolic(&bonus, sizeof(bonus), "bonus");
    // Add reasonable assumptions about bonus range
    klee_assume(bonus >= 0 && bonus <= 100);
    result += bonus;

    return result;
}
```
End_of_transformed_code

Key changes made:
1. Removed the external `calculate_bonus()` function call
2. Replaced it with a symbolic variable `bonus`
3. Added assumptions about the possible range of bonus values (0-100 in this case)
4. Kept the rest of the function logic identical
5. Added `klee.h` include for symbolic execution support

The transformation maintains the same behavior where:
- The input `x` is still doubled
- A bonus value is still added
- The return value remains the sum
But now KLEE can properly explore all possible paths through the bonus calculation.